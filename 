std::vector(3)                                                                                             C++ Standard Libary                                                                                             std::vector(3)

NNAAMMEE
       std::vector - std::vector

SSyynnooppssiiss
          Defined in header <vector>
          template<

              class T,                                                       ((11))
              class Allocator = std::allocator<T>

          > class vector;
          namespace pmr {

              template <class T>
              using vector = std::vector<T,                                  ((22)) _(_s_i_n_c_e _C_+_+_1_7_)
          std::pmr::polymorphic_allocator<T>>;

          }

          1) std::vector is a sequence container that encapsulates dynamic size arrays.
          2) std::pmr::vector is an alias template that uses a polymorphic allocator

          The elements are stored contiguously, which means that elements can be
          accessed not only through iterators, but also using offsets to regular
          pointers to elements. This means that a pointer to an element of a     (since C++03)
          vector may be passed to any function that expects a pointer to an
          element of an array.

          The storage of the vector is handled automatically, being expanded and contracted as
          needed. Vectors usually occupy more space than static arrays, because more memory is
          allocated to handle future growth. This way a vector does not need to reallocate
          each time an element is inserted, but only when the additional memory is exhausted.
          The total amount of allocated memory can be queried using capacity() function.
          Extra memory can be returned to the system via a call to shrink_to_fit().
          _(_s_i_n_c_e _C_+_+_1_1_)

          Reallocations are usually costly operations in terms of performance. The reserve()
          function can be used to eliminate reallocations if the number of elements is known
          beforehand.

          The complexity (efficiency) of common operations on vectors is as follows:

            * Random access - constant O(1)
            * Insertion or removal of elements at the end - amortized constant O(1)
            * Insertion or removal of elements - linear in the distance to the end of the
              vector O(n)

          std::vector (for T other than bool) meets the requirements of Container,
          AllocatorAwareContainer, SequenceContainer
          , ContiguousContainer
          _(_s_i_n_c_e _C_+_+_1_7_) and ReversibleContainer.

TTeemmppllaattee ppaarraammeetteerrss
                      The type of the elements.

                      T must meet the requirements of CopyAssignable and         _(_u_n_t_i_l _C_+_+_1_1_)
                      CopyConstructible.
                      The requirements that are imposed on the elements depend
                      on the actual operations performed on the container.       _(_s_i_n_c_e _C_+_+_1_1_)
                      Generally, it is required that element type is a complete  _(_u_n_t_i_l _C_+_+_1_7_)
                      type and meets the requirements of Erasable, but many
                      member functions impose stricter requirements.
          T         - The requirements that are imposed on the elements depend
                      on the actual operations performed on the container.
                      Generally, it is required that element type meets the
                      requirements of Erasable, but many member functions impose _(_s_i_n_c_e _C_+_+_1_7_)
                      stricter requirements. This container (but not its
                      members) can be instantiated with an incomplete element
                      type if the allocator satisfies the allocator completeness
                      requirements.

                      An allocator that is used to acquire/release memory and to
          Allocator - construct/destroy the elements in that memory. The type must meet the
                      requirements of Allocator. The behavior is undefined if
                      Allocator::value_type is not the same as T.

SSppeecciiaalliizzaattiioonnss
          The standard library provides a specialization of std::vector for the type bool,
          which may be optimized for space efficiency.

          vector<bool> space-efficient dynamic bitset
                       _(_c_l_a_s_s _t_e_m_p_l_a_t_e _s_p_e_c_i_a_l_i_z_a_t_i_o_n_)

          Iterator invalidation

           This section is incomplete

          There are still a few inaccuracies in this section. Refer to individual member
          function pages for more detail.

                    Operations                                Invalidated
          All read only operations, swap, Never
          std::swap
          clear, operator=, assign        Always
          reserve, shrink_to_fit          If the vector changed capacity, all of them. If not,
                                          none.
          erase                           Erased elements + all elements after them (including
                                          end())
          push_back, emplace_back         If the vector changed capacity, all of them. If not,
                                          only end().
          insert, emplace, resize         If the vector changed capacity, all of them. If not,
                                          only those after the insertion point.
          pop_back                        The element erased and end().

MMeemmbbeerr ttyyppeess
          Member type            Definition
          value_type             T
          allocator_type         Allocator
          size_type              Unsigned integer type (usually std::size_t)
          difference_type        Signed integer type (usually std::ptrdiff_t)
                                 Allocator::reference _(_u_n_t_i_l _C_+_+_1_1_)
          reference              value_type&          _(_s_i_n_c_e _C_+_+_1_1_)

                                 Allocator::const_reference _(_u_n_t_i_l _C_+_+_1_1_)
          const_reference        const value_type&          _(_s_i_n_c_e _C_+_+_1_1_)

                                 Allocator::pointer                        _(_u_n_t_i_l _C_+_+_1_1_)
          pointer                std::allocator_traits<Allocator>::pointer _(_s_i_n_c_e _C_+_+_1_1_)

                                 Allocator::const_pointer                        _(_u_n_t_i_l _C_+_+_1_1_)
          const_pointer          std::allocator_traits<Allocator>::const_pointer _(_s_i_n_c_e _C_+_+_1_1_)

          iterator               LegacyRandomAccessIterator
          const_iterator         Constant LegacyRandomAccessIterator
          reverse_iterator       std::reverse_iterator<iterator>
          const_reverse_iterator std::reverse_iterator<const_iterator>

MMeemmbbeerr ffuunnccttiioonnss
          constructor   constructs the vector
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          destructor    destructs the vector
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          operator=     assigns values to the container
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          assign        assigns values to the container
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          get_allocator returns the associated allocator
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)

EElleemmeenntt aacccceessss
          at            access specified element with bounds checking
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          operator[]    access specified element
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          front         access the first element
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          back          access the last element
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          data          direct access to the underlying array
          _(_C_+_+_1_1_)       _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)

IItteerraattoorrss
          begin         returns an iterator to the beginning
          cbegin        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          end           returns an iterator to the end
          cend          _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          rbegin        returns a reverse iterator to the beginning
          crbegin       _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          rend          returns a reverse iterator to the end
          crend         _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)

CCaappaacciittyy
          empty         checks whether the container is empty
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          size          returns the number of elements
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          max_size      returns the maximum possible number of elements
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          reserve       reserves storage
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
                        returns the number of elements that can be held in currently allocated
          capacity      storage
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          shrink_to_fit reduces memory usage by freeing unused memory
          _(_C_+_+_1_1_)       _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)

MMooddiiffiieerrss
          clear         clears the contents
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          insert        inserts elements
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          emplace       constructs element in-place
          _(_C_+_+_1_1_)       _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          erase         erases elements
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          push_back     adds an element to the end
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          emplace_back  constructs an element in-place at the end
          _(_C_+_+_1_1_)       _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          pop_back      removes the last element
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          resize        changes the number of elements stored
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)
          swap          swaps the contents
                        _(_p_u_b_l_i_c _m_e_m_b_e_r _f_u_n_c_t_i_o_n_)

NNoonn--mmeemmbbeerr ffuunnccttiioonnss
          operator==
          operator!=
          operator<              lexicographically compares the values in the vector
          operator<=             _(_f_u_n_c_t_i_o_n _t_e_m_p_l_a_t_e_)
          operator>
          operator>=
          std::swap(std::vector) specializes the std::swap algorithm
                                 _(_f_u_n_c_t_i_o_n _t_e_m_p_l_a_t_e_)
          erase(std::vector)     Erases all elements satisfying specific criteria
          erase_if(std::vector)  _(_f_u_n_c_t_i_o_n _t_e_m_p_l_a_t_e_)
          (C++20)

          Deduction guides_(_s_i_n_c_e _C_+_+_1_7_)

EExxaammppllee
       // Run this code

        #include <iostream>
        #include <vector>

        int main()
        {
            // Create a vector containing integers
            std::vector<int> v = {7, 5, 16, 8};

            // Add two more integers to vector
            v.push_back(25);
            v.push_back(13);

            // Iterate and print values of vector
            for(int n : v) {
                std::cout << n << '\n';
            }
        }

OOuuttppuutt::
        7
        5
        16
        8
        25
        13

CCaatteeggoorryy::
            * Todo without reason

http://cppreference.com                                                                                         2020.11.17                                                                                                 std::vector(3)
